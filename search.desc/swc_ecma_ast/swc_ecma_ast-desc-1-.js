searchState.loadedDescShard("swc_ecma_ast", 1, "The archived counterpart of <code>SuperPropExpr::span</code>\nThe archived counterpart of <code>CondExpr::span</code>\nThe archived counterpart of <code>CallExpr::span</code>\nThe archived counterpart of <code>NewExpr::span</code>\nThe archived counterpart of <code>SeqExpr::span</code>\nThe archived counterpart of <code>ArrowExpr::span</code>\nThe archived counterpart of <code>YieldExpr::span</code>\nThe archived counterpart of <code>MetaPropExpr::span</code>\nThe archived counterpart of <code>AwaitExpr::span</code>\nThe archived counterpart of <code>Tpl::span</code>\nThe archived counterpart of <code>TaggedTpl::span</code>\nThe archived counterpart of <code>TplElement::span</code>\nThe archived counterpart of <code>ParenExpr::span</code>\nThe archived counterpart of <code>Super::span</code>\nThe archived counterpart of <code>Import::span</code>\nThe archived counterpart of <code>OptChainExpr::span</code>\nThe archived counterpart of <code>OptCall::span</code>\nSpan including <code>[</code> and <code>]</code>.\nSpan including the braces.\nSpan of semicolon.\nThe archived counterpart of <code>Invalid::span</code>\nReturns <code>Some</code> if <code>self</code> is of variant <code>Spread</code>, and <code>None</code> …\nThe archived counterpart of <code>ExprOrSpread::spread</code>\nReturns the truncated principal square root of <code>self</code> – …\nReturns <code>Some</code> if <code>self</code> is of variant <code>StaticBlock</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>Stmt</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>Str</code>, and <code>None</code> otherwise.\nReturns <code>Some</code> if <code>self</code> is of variant <code>Str</code>, and <code>None</code> otherwise.\nReturns <code>Some</code> if <code>self</code> is of variant <code>Str</code>, and <code>None</code> otherwise.\nReturns <code>Some</code> if <code>self</code> is of variant <code>Str</code>, and <code>None</code> otherwise.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nReturns <code>Some</code> if <code>self</code> is of variant <code>Super</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>SuperProp</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>SuperProp</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>Switch</code>, and <code>None</code> …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe archived counterpart of <code>TaggedTpl::tag</code>\nReturns <code>Some</code> if <code>self</code> is of variant <code>TaggedTpl</code>, and <code>None</code> …\nThe archived counterpart of <code>TplElement::tail</code>\nThe archived counterpart of <code>CondExpr::test</code>\nNone for <code>default:</code>\nReturns <code>Some</code> if <code>self</code> is of variant <code>This</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>Throw</code>, and <code>None</code> …\nConverts this <code>BigInt</code> into a <code>BigUint</code>, if it’s not …\nReturns the sign and the byte representation of the <code>BigInt</code> …\nReturns the sign and the byte representation of the <code>BigInt</code> …\nSee <code>Ident::to_id</code> for documentation.\nCreates <code>Id</code> using <code>Atom</code> and <code>SyntaxContext</code> of <code>self</code>.\nReturns the integer in the requested base in big-endian …\nReturns the integer in the requested base in little-endian …\nReturns the two’s-complement byte representation of the …\nReturns the two’s-complement byte representation of the …\nReturns the integer formatted as a string in the given …\nReturns the sign and the <code>u32</code> digits representation of the …\nReturns the sign and the <code>u64</code> digits representation of the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nReturns <code>Some</code> if <code>self</code> is of variant <code>Tpl</code>, and <code>None</code> otherwise.\nReturns <code>Some</code> if <code>self</code> is of variant <code>Tpl</code>, and <code>None</code> otherwise.\nThe archived counterpart of <code>TaggedTpl::tpl</code>\nThis is boxed to reduce the type size of Expr.\nReturns the number of least-significant bits that are zero,\nReturns <code>Some</code> if <code>self</code> is of variant <code>Try</code>, and <code>None</code> otherwise.\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsArrayType</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsAs</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsAs</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsCallSignatureDecl</code>, …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsConditionalType</code>, and …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsConstAssertion</code>, and …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsConstructSignatureDecl</code>…\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsConstructorType</code>, and …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsEntityName</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsEntityName</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsEnum</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsExportAssignment</code>, and …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsExternalModuleRef</code>, …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsFnOrConstructorType</code>, …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsFnType</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsGetterSignature</code>, and …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsImportEquals</code>, and <code>None</code>…\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsImportType</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsIndexSignature</code>, and …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsIndexSignature</code>, and …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsIndexedAccessType</code>, …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsInferType</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsInstantiation</code>, and …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsInstantiation</code>, and …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsInterface</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsInterfaceDecl</code>, and …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsIntersectionType</code>, and …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsKeywordType</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsLitType</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsMappedType</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsMethodSignature</code>, and …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsModule</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsModuleBlock</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsNamespaceDecl</code>, and …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsNamespaceExport</code>, and …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsNonNull</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsNonNull</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsOptionalType</code>, and <code>None</code>…\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsParamProp</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsParenthesizedType</code>, …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsPropertySignature</code>, …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsQualifiedName</code>, and …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsRestType</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsSatisfies</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsSatisfies</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsSetterSignature</code>, and …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsThisType</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsThisType</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsTupleType</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsTypeAlias</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsTypeAssertion</code>, and …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsTypeAssertion</code>, and …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsTypeLit</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsTypeOperator</code>, and <code>None</code>…\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsTypePredicate</code>, and …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsTypeQuery</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsTypeRef</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant …\nReturns <code>Some</code> if <code>self</code> is of variant <code>TsUnionType</code>, and <code>None</code> …\nThe archived counterpart of <code>CallExpr::type_args</code>\nThe archived counterpart of <code>NewExpr::type_args</code>\nThe archived counterpart of <code>OptCall::type_args</code>\nNote: This field’s name is different from one from babel …\nThe archived counterpart of <code>ArrowExpr::type_params</code>\nThe archived counterpart of <code>TaggedTpl::type_params</code>\nReturns <code>Some</code> if <code>self</code> is of variant <code>Unary</code>, and <code>None</code> …\nCreates <code>void 0</code>.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nUnwraps an expression with a given function.\nNormalize parenthesized expressions.\nNormalize parenthesized expressions.\nNormalize sequences and parenthesized expressions.\nUnwraps an expression with a given function.\nReturns <code>Some</code> if <code>self</code> is of variant <code>Update</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>Using</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>UsingDecl</code>, and <code>None</code> …\nBabel uses Expr instead of JSXAttrValue\n<strong>Note</strong>: This should not be <code>NaN</code>. Use crate::Ident to …\nReturns <code>Some</code> if <code>self</code> is of variant <code>Var</code>, and <code>None</code> otherwise.\nReturns <code>Some</code> if <code>self</code> is of variant <code>VarDecl</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>VarDecl</code>, and <code>None</code> …\nAlternative for <code>toIdentifier</code> of babel.\nReturns <code>Some</code> if <code>self</code> is of variant <code>While</code>, and <code>None</code> …\nReturns <code>Some</code> if <code>self</code> is of variant <code>With</code>, and <code>None</code> …\nCreate a new identifier with the given position.\nCreate a new identifier with the given prefix.\n#Note\nIn <code>op</code>, EqIgnoreSpan of Ident will ignore the syntax …\nPreserve syntax context while drop <code>span.lo</code> and <code>span.hi</code>.\nReturns <code>Some</code> if <code>self</code> is of variant <code>Yield</code>, and <code>None</code> …")